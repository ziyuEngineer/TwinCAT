///////////////////////////////////////////////////////////////////////////////
// MotionControl.cpp
#include "TcPch.h"
#pragma hdrstop

#include "MotionControl.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#endif
DEFINE_THIS_FILE()

///////////////////////////////////////////////////////////////////////////////
// CMotionControl
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Collection of interfaces implemented by module CMotionControl
BEGIN_INTERFACE_MAP(CMotionControl)
	INTERFACE_ENTRY_ITCOMOBJECT()
	INTERFACE_ENTRY(IID_ITcADI, ITcADI)
	INTERFACE_ENTRY(IID_ITcWatchSource, ITcWatchSource)
///<AutoGeneratedContent id="InterfaceMap">
	INTERFACE_ENTRY(IID_ITcCyclic, ITcCyclic)
	INTERFACE_ENTRY(IID_IMotionControlInterface, IMotionControlInterface)
///</AutoGeneratedContent>
END_INTERFACE_MAP()


IMPLEMENT_ITCOMOBJECT(CMotionControl)
IMPLEMENT_ITCOMOBJECT_SETSTATE_LOCKOP2(CMotionControl)
IMPLEMENT_ITCADI(CMotionControl)
IMPLEMENT_ITCWATCHSOURCE(CMotionControl)


///////////////////////////////////////////////////////////////////////////////
// Set parameters of CMotionControl 
BEGIN_SETOBJPARA_MAP(CMotionControl)
	SETOBJPARA_DATAAREA_MAP()
///<AutoGeneratedContent id="SetObjectParameterMap">
	SETOBJPARA_VALUE(PID_TcTraceLevel, m_TraceLevelMax)
	SETOBJPARA_VALUE(PID_MotionControlParameter, m_Parameter)
	SETOBJPARA_ITFPTR(PID_Ctx_TaskOid, m_spCyclicCaller)
	SETOBJPARA_ITFPTR(PID_MotionControlPLC_PanelProcess, m_spPLC_PanelProcess)
	SETOBJPARA_ITFPTR(PID_MotionControlModuleSpindle_Interface, m_spModuleSpindle_Interface)
	SETOBJPARA_ITFPTR(PID_MotionControlModuleAxisGroup_Interface, m_spModuleAxisGroup_Interface)
	SETOBJPARA_ITFPTR(PID_MotionControlPLC_ScopeProcess, m_spPLC_ScopeProcess)
///</AutoGeneratedContent>
END_SETOBJPARA_MAP()

///////////////////////////////////////////////////////////////////////////////
// Get parameters of CMotionControl 
BEGIN_GETOBJPARA_MAP(CMotionControl)
	GETOBJPARA_DATAAREA_MAP()
///<AutoGeneratedContent id="GetObjectParameterMap">
	GETOBJPARA_VALUE(PID_TcTraceLevel, m_TraceLevelMax)
	GETOBJPARA_VALUE(PID_MotionControlParameter, m_Parameter)
	GETOBJPARA_ITFPTR(PID_Ctx_TaskOid, m_spCyclicCaller)
	GETOBJPARA_ITFPTR(PID_MotionControlPLC_PanelProcess, m_spPLC_PanelProcess)
	GETOBJPARA_ITFPTR(PID_MotionControlModuleSpindle_Interface, m_spModuleSpindle_Interface)
	GETOBJPARA_ITFPTR(PID_MotionControlModuleAxisGroup_Interface, m_spModuleAxisGroup_Interface)
	GETOBJPARA_ITFPTR(PID_MotionControlPLC_ScopeProcess, m_spPLC_ScopeProcess)
///</AutoGeneratedContent>
END_GETOBJPARA_MAP()

///////////////////////////////////////////////////////////////////////////////
// Get watch entries of CMotionControl
BEGIN_OBJPARAWATCH_MAP(CMotionControl)
	OBJPARAWATCH_DATAAREA_MAP()
///<AutoGeneratedContent id="ObjectParameterWatchMap">
	OBJPARAWATCH_VALUE(PID_MotionControlParameter, m_Parameter)
///</AutoGeneratedContent>
END_OBJPARAWATCH_MAP()

///////////////////////////////////////////////////////////////////////////////
// Get data area members of CMotionControl
BEGIN_OBJDATAAREA_MAP(CMotionControl)
///<AutoGeneratedContent id="ObjectDataAreaMap">
	OBJDATAAREA_VALUE(ADI_MotionControlInputs, m_Inputs)
	OBJDATAAREA_VALUE(ADI_MotionControlOutputs, m_Outputs)
///</AutoGeneratedContent>
END_OBJDATAAREA_MAP()


///////////////////////////////////////////////////////////////////////////////
CMotionControl::CMotionControl()
	: m_Trace(m_TraceLevelMax, m_spSrv)
{
///<AutoGeneratedContent id="MemberInitialization">
	m_TraceLevelMax = tlAlways;
	m_Parameter = FALSE;
	memset(&m_Inputs, 0, sizeof(m_Inputs));
	memset(&m_Outputs, 0, sizeof(m_Outputs));
///</AutoGeneratedContent>
	m_spEventLogger = 0;
	m_spMessage = 0;
}

///////////////////////////////////////////////////////////////////////////////
CMotionControl::~CMotionControl() 
{
}


///////////////////////////////////////////////////////////////////////////////
// State Transitions 
///////////////////////////////////////////////////////////////////////////////
IMPLEMENT_ITCOMOBJECT_SETOBJSTATE_IP_PI(CMotionControl)

///////////////////////////////////////////////////////////////////////////////
// State transition from PREOP to SAFEOP
//
// Initialize input parameters 
// Allocate memory
HRESULT CMotionControl::SetObjStatePS(PTComInitDataHdr pInitData)
{
	m_Trace.Log(tlVerbose, FENTERA);
	HRESULT hr = S_OK;
	IMPLEMENT_ITCOMOBJECT_EVALUATE_INITDATA(pInitData);

	m_Controller.MapParameters(&m_Inputs, &m_Outputs);
	m_Controller.m_Trace = &m_Trace;
	
	m_MainStateMachine->s_pController = &m_Controller;
	m_MainStateMachine->start();

	m_Trace.Log(tlVerbose, FLEAVEA "hr=0x%08x", hr);
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
// State transition from SAFEOP to OP
//
// Register with other TwinCAT objects
HRESULT CMotionControl::SetObjStateSO()
{
	m_Trace.Log(tlVerbose, FENTERA);
	HRESULT hr = S_OK;

	// If following call is successful the CycleUpdate method will be called, 
	// possibly even before method has been left.
	hr = FAILED(hr) ? hr : AddModuleToCaller(); 

	m_spEventLogger.SetOID(OID_TCEVENTLOGGER);
	hr = FAILED(hr) ? hr : m_spSrv->TcQuerySmartObjectInterface(m_spEventLogger);
	hr = FAILED(hr) ? hr : m_spEventLogger->CreateMessage(TcEvents::MainEvent::EventClass, TcEvents::MainEvent::MainModuleStart.nEventId, TcEvents::MainEvent::MainModuleStart.eSeverity, &TcSourceInfo("Main Module"), &m_spMessage);
	
	// Cleanup if transition failed at some stage
	if ( FAILED(hr) )
	{
		RemoveModuleFromCaller(); 
		m_spEventLogger = NULL;
		m_spMessage = NULL;
	}
	else
	{
		m_spMessage->Send(0);
		CMainController::m_pEventLogger = m_spEventLogger;
		CMainController::m_pMessage = m_spMessage;
	}

	m_Trace.Log(tlVerbose, FLEAVEA "hr=0x%08x", hr);
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
// State transition from OP to SAFEOP
HRESULT CMotionControl::SetObjStateOS()
{
	m_Trace.Log(tlVerbose, FENTERA);

	HRESULT hr = S_OK;

	RemoveModuleFromCaller(); 

	// Deinitialization
	m_spPLC_PanelProcess = NULL;
	m_spModuleSpindle_Interface = NULL;
	m_spModuleAxisGroup_Interface = NULL;

	m_spEventLogger = NULL;
	m_spMessage = NULL;

	m_Trace.Log(tlVerbose, FLEAVEA "hr=0x%08x", hr);
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
// State transition from SAFEOP to PREOP
HRESULT CMotionControl::SetObjStateSP()
{
	HRESULT hr = S_OK;
	m_Trace.Log(tlVerbose, FENTERA);

	m_Trace.Log(tlVerbose, FLEAVEA "hr=0x%08x", hr);
	return hr;
}

///<AutoGeneratedContent id="ImplementationOf_ITcCyclic">
HRESULT CMotionControl::CycleUpdate(ITcTask* ipTask, ITcUnknown* ipCaller, ULONG_PTR context)
{
	HRESULT hr = S_OK;

	if (!m_IsRpcReady)
	{
		m_IsRpcReady = InitializePlcRpc() && InitializeOtherModuleRpc();
		m_WaitingRpcCounter++;
		if (m_WaitingRpcCounter > m_MaxWaitingRpcCounter)
		{
			m_Trace.Log(tlError, FLEAVEA "Level tlError : Main module failed to initialize rpc.");
			m_spEventLogger->CreateMessage(TcEvents::MainEvent::EventClass, TcEvents::MainEvent::MainModuleRpcInit.nEventId, TcEvents::MainEvent::MainModuleRpcInit.eSeverity, &TcSourceInfo("Main Module"), &m_spMessage);
			m_spMessage->Send(0);
			m_WaitingRpcCounter = 0;
		}
	}
	else
	{
		m_Controller.Input();

		m_MainStateMachine->dispatch(EventCycleUpdate());

		m_Controller.Output();
	}
	
	return hr;
}
///</AutoGeneratedContent>

///////////////////////////////////////////////////////////////////////////////
HRESULT CMotionControl::AddModuleToCaller()
{
	m_Trace.Log(tlVerbose, FENTERA);

	HRESULT hr = S_OK;
	if ( m_spCyclicCaller.HasOID() )
	{
		if ( SUCCEEDED_DBG(hr = m_spSrv->TcQuerySmartObjectInterface(m_spCyclicCaller)) )
		{
			if ( FAILED(hr = m_spCyclicCaller->AddModule(m_spCyclicCaller, THIS_CAST(ITcCyclic))) )
			{
				m_spCyclicCaller = NULL;
			}
		}
	}
	else
	{
		hr = ADS_E_INVALIDOBJID; 
		SUCCEEDED_DBGT(hr, "Invalid OID specified for caller task");
	}

	m_Trace.Log(tlVerbose, FLEAVEA "hr=0x%08x", hr);
	return hr;
}

///////////////////////////////////////////////////////////////////////////////
VOID CMotionControl::RemoveModuleFromCaller()
{
	m_Trace.Log(tlVerbose, FENTERA);

	if ( m_spCyclicCaller )
	{
		m_spCyclicCaller->RemoveModule(m_spCyclicCaller);
	}
	m_spCyclicCaller	= NULL;

	m_Trace.Log(tlVerbose, FLEAVEA);
}

bool CMotionControl::InitializePlcRpc()
{
	bool is_initialized = false;
	
	if ((m_spPLC_ScopeProcess == NULL) && m_Inputs.OidScopeProcess != 0)
	{
		m_spPLC_ScopeProcess.SetOID(m_Inputs.OidScopeProcess);
		m_spSrv->TcQuerySmartObjectInterface(m_spPLC_ScopeProcess);
		is_initialized = false;
	}

	if ((m_spPLC_PanelProcess == NULL) && m_Inputs.OidPanelProcess != 0)
	{
		m_spPLC_PanelProcess.SetOID(m_Inputs.OidPanelProcess);
		m_spSrv->TcQuerySmartObjectInterface(m_spPLC_PanelProcess);
		is_initialized = false;
	}

	if (m_spPLC_PanelProcess != NULL)
	{
		is_initialized = (m_spPLC_PanelProcess->mInitialize() == S_OK) ? true : false;
		CMainController::m_pPanelProcess = m_spPLC_PanelProcess;
	}

	return is_initialized;
}

bool CMotionControl::InitializeOtherModuleRpc()
{
	bool is_initialized = false;
	
	if( (m_spSrv->TcQuerySmartObjectInterface(m_spModuleSpindle_Interface) == S_OK)
		&& (m_spSrv->TcQuerySmartObjectInterface(m_spModuleAxisGroup_Interface) == S_OK))
	{
		CMainController::m_pSpindleInterface = m_spModuleSpindle_Interface;
		CMainController::m_pAxisGroupInterface = m_spModuleAxisGroup_Interface;
		is_initialized = true;
	}
	
	return is_initialized;
}

///<AutoGeneratedContent id="ImplementationOf_IMotionControlInterface">
HRESULT CMotionControl::ExecuteCommandsContinuously(ULONG n_min_data_start, ULONG& buffer_size, OpMode op_mode)
{
	HRESULT hr = S_OK;
	
	buffer_size = m_Controller.GetMaxBufferSize();

	if (!m_Controller.IsReadyToMove())
	{
		return (HRESULT)ADSERR_DEVICE_BUSY;
	}
	
	if (!m_Controller.IsReadyToReceiveCmd())
	{
		return (HRESULT)ADSERR_DEVICE_INVALIDDATA;
	}
	
	EventContinuousExecution event_continuous_execution{};
	event_continuous_execution.minDataToStart = n_min_data_start;
	event_continuous_execution.axisgroupOpMode = op_mode;
	
	m_MainStateMachine->dispatch(event_continuous_execution);

	return hr;
}

HRESULT CMotionControl::EnterRecoveryState(bool is_entered)
{
	HRESULT hr = (HRESULT)ADSERR_NOERR;
	
	if (is_entered)
	{
		m_MainStateMachine->dispatch(EventRequestEnterRecoveryState());
	}
	else
	{
		m_MainStateMachine->dispatch(EventRequestExitRecoveryState());
	}

	return hr;
}

HRESULT CMotionControl::RequestStop()
{
	HRESULT hr = S_OK;

	m_MainStateMachine->dispatch(EventStopContinuousMoving());

	return hr;
}

HRESULT CMotionControl::EnterFaultState()
{
	HRESULT hr = S_OK;

	m_MainStateMachine->dispatch(EventRequestEnterFaultState());

	return hr;
}

HRESULT CMotionControl::ExitFaultState()
{
	HRESULT hr = S_OK;

	m_MainStateMachine->dispatch(EventRequestExitFaultState());

	return hr;
}

HRESULT CMotionControl::EnterStandbyState()
{
	HRESULT hr = S_OK;

	m_MainStateMachine->dispatch(EventRequestEnterStandbyState());

	return hr;
}

HRESULT CMotionControl::EnterDisabledState()
{
	HRESULT hr = S_OK;

	m_MainStateMachine->dispatch(EventRequestEnterDisabledState());

	return hr;
}

HRESULT CMotionControl::ScopeInitialize()
{
	HRESULT hr = S_OK;
	m_spPLC_ScopeProcess->mInitialize();
	return hr;
}

HRESULT CMotionControl::ScopeStartRecord()
{
	HRESULT hr = S_OK;
	m_spPLC_ScopeProcess->mStartRecord();
	return hr;
}

HRESULT CMotionControl::ScopeStopRecord()
{
	HRESULT hr = S_OK;
	m_spPLC_ScopeProcess->mStopRecord();
	return hr;
}

HRESULT CMotionControl::ScopeExportData()
{
	HRESULT hr = S_OK;
	m_spPLC_ScopeProcess->mExportData();
	return hr;
}

HRESULT CMotionControl::ExecuteAxisGroupPositioning(PositioningAxis& axis, PositioningTarget& target)
{
	HRESULT hr = S_OK;
			
	if (!m_Controller.IsAxisGroupReadyForPositioning())
	{
		return (HRESULT)ADSERR_DEVICE_BUSY;
	}
			
	EventRequestAxisGroupPositioning event_positioning{};
	
	for (int i = 0; i < kMaxAxisNum; i++)
	{
		event_positioning.enabled_axis[i] = axis[i];
		event_positioning.target[i] = target[i];
	}

	m_MainStateMachine->dispatch(event_positioning);
			
	return hr;
}

HRESULT CMotionControl::ExecuteToolSwitching(SHORT tool_num)
{
	HRESULT hr = S_OK;

	if (!m_Controller.IsReadyToSwitchTool())
	{
		return (HRESULT)ADSERR_DEVICE_BUSY;
	}

	EventRequestToolSwitch event_tool_switch{};
	event_tool_switch.tool_number = tool_num;

	m_MainStateMachine->dispatch(event_tool_switch);

	return hr;
}
///</AutoGeneratedContent>

